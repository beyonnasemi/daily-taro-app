{"ast":null,"code":"import _objectSpread from\"/private/tmp/workspace/daily-taro-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// 애니메이션 관련 유틸리티 함수들\n/**\n * 요소에 애니메이션 클래스를 추가하고 완료 후 제거\n * @param {HTMLElement} element - 애니메이션을 적용할 요소\n * @param {string} animationClass - 애니메이션 CSS 클래스\n * @param {number} duration - 애니메이션 지속 시간 (ms)\n */export const addTemporaryAnimation=function(element,animationClass){let duration=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1000;if(!element)return;element.classList.add(animationClass);setTimeout(()=>{element.classList.remove(animationClass);},duration);};/**\n * 지연된 애니메이션 실행\n * @param {Function} callback - 실행할 콜백 함수\n * @param {number} delay - 지연 시간 (ms)\n * @returns {number} 타이머 ID\n */export const delayedAnimation=function(callback){let delay=arguments.length>1&&arguments[1]!==undefined?arguments[1]:500;return setTimeout(callback,delay);};/**\n * 스태거 애니메이션 (순차적 애니메이션)\n * @param {NodeList|Array} elements - 애니메이션을 적용할 요소들\n * @param {string} animationClass - 애니메이션 CSS 클래스\n * @param {number} staggerDelay - 각 요소간 지연 시간 (ms)\n */export const staggerAnimation=function(elements,animationClass){let staggerDelay=arguments.length>2&&arguments[2]!==undefined?arguments[2]:100;elements.forEach((element,index)=>{setTimeout(()=>{element.classList.add(animationClass);},index*staggerDelay);});};/**\n * 카드 셔플 애니메이션 효과\n * @param {HTMLElement} cardElement - 카드 요소\n * @returns {Promise} 애니메이션 완료 프로미스\n */export const shuffleCardAnimation=cardElement=>{return new Promise(resolve=>{if(!cardElement){resolve();return;}const animationClass='shuffle-animation';cardElement.classList.add(animationClass);const handleAnimationEnd=()=>{cardElement.classList.remove(animationClass);cardElement.removeEventListener('animationend',handleAnimationEnd);resolve();};cardElement.addEventListener('animationend',handleAnimationEnd);// 애니메이션이 실행되지 않을 경우를 대비한 fallback\nsetTimeout(()=>{if(cardElement.classList.contains(animationClass)){cardElement.classList.remove(animationClass);resolve();}},2000);});};/**\n * 부드러운 스크롤 애니메이션\n * @param {HTMLElement} targetElement - 스크롤할 대상 요소\n * @param {Object} options - 스크롤 옵션\n */export const smoothScrollTo=function(targetElement){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!targetElement)return;const defaultOptions={behavior:'smooth',block:'center',inline:'nearest'};targetElement.scrollIntoView(_objectSpread(_objectSpread({},defaultOptions),options));};/**\n * 요소의 가시성 체크 후 애니메이션 실행\n * @param {HTMLElement} element - 체크할 요소\n * @param {Function} callback - 가시상태일 때 실행할 콜백\n * @param {Object} options - Intersection Observer 옵션\n */export const animateOnVisible=function(element,callback){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(!element||!window.IntersectionObserver){callback();return;}const defaultOptions={threshold:0.1,rootMargin:'0px 0px -50px 0px'};const observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{if(entry.isIntersecting){callback();observer.unobserve(element);}});},_objectSpread(_objectSpread({},defaultOptions),options));observer.observe(element);};/**\n * 랜덤 반짝임 효과\n * @param {HTMLElement} element - 반짝임을 적용할 요소\n * @param {number} duration - 반짝임 지속 시간 (ms)\n */export const sparkleEffect=function(element){let duration=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2000;if(!element)return;const sparkleClass='sparkle-effect';element.classList.add(sparkleClass);setTimeout(()=>{element.classList.remove(sparkleClass);},duration);};/**\n * 진동 효과 (모바일)\n * @param {number|Array} pattern - 진동 패턴 (ms)\n */export const vibrateEffect=function(){let pattern=arguments.length>0&&arguments[0]!==undefined?arguments[0]:100;if('vibrate'in navigator){navigator.vibrate(pattern);}};","map":{"version":3,"names":["addTemporaryAnimation","element","animationClass","duration","arguments","length","undefined","classList","add","setTimeout","remove","delayedAnimation","callback","delay","staggerAnimation","elements","staggerDelay","forEach","index","shuffleCardAnimation","cardElement","Promise","resolve","handleAnimationEnd","removeEventListener","addEventListener","contains","smoothScrollTo","targetElement","options","defaultOptions","behavior","block","inline","scrollIntoView","_objectSpread","animateOnVisible","window","IntersectionObserver","threshold","rootMargin","observer","entries","entry","isIntersecting","unobserve","observe","sparkleEffect","sparkleClass","vibrateEffect","pattern","navigator","vibrate"],"sources":["/private/tmp/workspace/daily-taro-app/src/utils/animationUtils.js"],"sourcesContent":["// 애니메이션 관련 유틸리티 함수들\n\n/**\n * 요소에 애니메이션 클래스를 추가하고 완료 후 제거\n * @param {HTMLElement} element - 애니메이션을 적용할 요소\n * @param {string} animationClass - 애니메이션 CSS 클래스\n * @param {number} duration - 애니메이션 지속 시간 (ms)\n */\nexport const addTemporaryAnimation = (element, animationClass, duration = 1000) => {\n  if (!element) return;\n\n  element.classList.add(animationClass);\n\n  setTimeout(() => {\n    element.classList.remove(animationClass);\n  }, duration);\n};\n\n/**\n * 지연된 애니메이션 실행\n * @param {Function} callback - 실행할 콜백 함수\n * @param {number} delay - 지연 시간 (ms)\n * @returns {number} 타이머 ID\n */\nexport const delayedAnimation = (callback, delay = 500) => {\n  return setTimeout(callback, delay);\n};\n\n/**\n * 스태거 애니메이션 (순차적 애니메이션)\n * @param {NodeList|Array} elements - 애니메이션을 적용할 요소들\n * @param {string} animationClass - 애니메이션 CSS 클래스\n * @param {number} staggerDelay - 각 요소간 지연 시간 (ms)\n */\nexport const staggerAnimation = (elements, animationClass, staggerDelay = 100) => {\n  elements.forEach((element, index) => {\n    setTimeout(() => {\n      element.classList.add(animationClass);\n    }, index * staggerDelay);\n  });\n};\n\n/**\n * 카드 셔플 애니메이션 효과\n * @param {HTMLElement} cardElement - 카드 요소\n * @returns {Promise} 애니메이션 완료 프로미스\n */\nexport const shuffleCardAnimation = (cardElement) => {\n  return new Promise((resolve) => {\n    if (!cardElement) {\n      resolve();\n      return;\n    }\n\n    const animationClass = 'shuffle-animation';\n    cardElement.classList.add(animationClass);\n\n    const handleAnimationEnd = () => {\n      cardElement.classList.remove(animationClass);\n      cardElement.removeEventListener('animationend', handleAnimationEnd);\n      resolve();\n    };\n\n    cardElement.addEventListener('animationend', handleAnimationEnd);\n\n    // 애니메이션이 실행되지 않을 경우를 대비한 fallback\n    setTimeout(() => {\n      if (cardElement.classList.contains(animationClass)) {\n        cardElement.classList.remove(animationClass);\n        resolve();\n      }\n    }, 2000);\n  });\n};\n\n/**\n * 부드러운 스크롤 애니메이션\n * @param {HTMLElement} targetElement - 스크롤할 대상 요소\n * @param {Object} options - 스크롤 옵션\n */\nexport const smoothScrollTo = (targetElement, options = {}) => {\n  if (!targetElement) return;\n\n  const defaultOptions = {\n    behavior: 'smooth',\n    block: 'center',\n    inline: 'nearest'\n  };\n\n  targetElement.scrollIntoView({ ...defaultOptions, ...options });\n};\n\n/**\n * 요소의 가시성 체크 후 애니메이션 실행\n * @param {HTMLElement} element - 체크할 요소\n * @param {Function} callback - 가시상태일 때 실행할 콜백\n * @param {Object} options - Intersection Observer 옵션\n */\nexport const animateOnVisible = (element, callback, options = {}) => {\n  if (!element || !window.IntersectionObserver) {\n    callback();\n    return;\n  }\n\n  const defaultOptions = {\n    threshold: 0.1,\n    rootMargin: '0px 0px -50px 0px'\n  };\n\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        callback();\n        observer.unobserve(element);\n      }\n    });\n  }, { ...defaultOptions, ...options });\n\n  observer.observe(element);\n};\n\n/**\n * 랜덤 반짝임 효과\n * @param {HTMLElement} element - 반짝임을 적용할 요소\n * @param {number} duration - 반짝임 지속 시간 (ms)\n */\nexport const sparkleEffect = (element, duration = 2000) => {\n  if (!element) return;\n\n  const sparkleClass = 'sparkle-effect';\n  element.classList.add(sparkleClass);\n\n  setTimeout(() => {\n    element.classList.remove(sparkleClass);\n  }, duration);\n};\n\n/**\n * 진동 효과 (모바일)\n * @param {number|Array} pattern - 진동 패턴 (ms)\n */\nexport const vibrateEffect = (pattern = 100) => {\n  if ('vibrate' in navigator) {\n    navigator.vibrate(pattern);\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}